esphome:
  name: heatingpump
  friendly_name: "Heating Pump CAN Interface"
  area: heizungskeller
  platform: ESP32
  board: esp32dev
# Enable Home Assistant API


# Enable logging
logger:
  level: DEBUG

ota:
  password: ""

api:
  password: ""
  services:
    - service: pull_canmsg
      variables:
        idx: int
        addr: int
        val: int
      then:
        - lambda: |-
            int getA = static_cast<int>(addr); //Adresse in Byte 0 u. 1 schreiben
            id(sh_state)[0]=getA>>8;
            id(sh_state)[1]=getA-((getA>>8)<<8);

            getA = static_cast<int>(idx); //Elster-Index übernehmen // Ota käyttöön Elster-indeksi
            //Wenn Elster-Index <= 0xff => an Byte-Stelle 2 schreiben //Jos Elster-indeksi <= 0xff => kirjoita tavupaikkaan 2
            if( (getA>>8) == 0x00) {
              id(sh_state)[2]=getA-((getA>>8)<<8);

              getA = static_cast<int>(val); //Datenwert übernehmen und an Stelle 3 u. 4 schreiben, 5 u. 6 ist 0x00 // Ota tietoarvo ja kirjoita paikkoihin 3 ja 4, 5 ja 6 on 0x00
              id(sh_state)[3]=getA>>8;
              id(sh_state)[4]=getA-((getA>>8)<<8);
              id(sh_state)[5]=0x00;
              id(sh_state)[6]=0x00;
            } else {
              //Wenn Elster-Index > 0xff kommt 0xfa an Stelle 2, der Index steht dann an Stelle 3 u. 4 //Jos Elster-indeksi > 0xff, 0xfa tulee paikalleen 2, indeksi on silloin paikoissa 3 ja 4
              id(sh_state)[2]=0xfa;
              id(sh_state)[3]=getA>>8;
              id(sh_state)[4]=getA-((getA>>8)<<8);

              getA = static_cast<int>(val); //der Datenwert steht dann an Stelle 5 u. 6 //tietoarvo on silloin paikoissa 5 ja 6
              id(sh_state)[5]=getA>>8;
              id(sh_state)[6]=getA-((getA>>8)<<8);
            }


wifi:
#  fast_connect: true
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: heatingpump

# Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Heatpump Fallback Hotspot"
    password: "Td6mth2TGTF6"

#Temporaly removed when debuging wifi problem..
#captive_portal:


web_server:
  port: 80
  auth:
    username: !secret web_uname
    password: !secret web_pw

#Joku bugi, ilman debugia wifiin yhditäminen failaa
#Bug? WiFi connection fails without debug..
debug:

globals:


#Array zum Senden von Can-Bus Befehl aus Home-Assistant
#Matriisi Can-Bus-komennon lähettämiseen Home Assistantista
  - id: sh_state
    type: int[7]
    initial_value: '{0x00,0x00,0x00,0x00,0x00,0x00,0x00}'
    restore_value: no
#Array zum Senden von Can-Bus Befehl aus Programmcode
#Matriisi Can-Bus-komennon lähettämiseen ohjelmakoodista
  - id: send_state
    type: int[7]
    initial_value: '{0x00,0x00,0x00,0x00,0x00,0x00,0x00}'
    restore_value: no






  - id: el_aufnahmeleistung_ww_tag_wh_float
    type: float
    restore_value: no
  - id: el_aufnahmeleistung_ww_tag_wh_flag
    type: bool
    restore_value: no
  - id: el_aufnahmeleistung_ww_tag_kwh
    type: float
    restore_value: no
  - id: el_aufnahmeleistung_ww_tag_kwh_flag
    type: bool
    restore_value: no
  - id: el_aufnahmeleistung_heiz_tag_wh_float
    type: float
    restore_value: no
  - id: el_aufnahmeleistung_heiz_tag_wh_flag
    type: bool
    restore_value: no
  - id: el_aufnahmeleistung_heiz_tag_kwh
    type: float
    restore_value: no
  - id: el_aufnahmeleistung_heiz_tag_kwh_flag
    type: bool
    restore_value: no 
  - id: el_aufnahmeleistung_ww_total_kWh_float
    type: float
    restore_value: no
  - id: el_aufnahmeleistung_ww_total_kWh_flag
    type: bool
    restore_value: no
  - id: el_aufnahmeleistung_ww_total_mWh
    type: float
    restore_value: no
  - id: el_aufnahmeleistung_ww_total_mWh_flag
    type: bool
    restore_value: no
  - id: el_aufnahmeleistung_heiz_total_kWh_float
    type: float
    restore_value: no
  - id: el_aufnahmeleistung_heiz_total_kWh_flag
    type: bool
    restore_value: no
  - id: el_aufnahmeleistung_heiz_total_mWh
    type: float
    restore_value: no

    
  - id: volumenstrom_float
    type: float
    restore_value: no

  - id: el_aufnahmeleistung_heiz_total_mWh_flag
    type: bool
    restore_value: no

  - id: VD_starts_h
    type: int
    initial_value: '0'
    restore_value: no

  - id: VD_starts_t
    initial_value: '0'
    type: float
    restore_value: no

  - id: waermemertrag_ww_tag_wh_float
    type: float
    restore_value: no
  - id: waermemertrag_ww_tag_wh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_ww_tag_kwh
    type: float
    restore_value: no
  - id: waermemertrag_ww_tag_kwh_flag
    type: bool
    
  - id: waermemertrag_electr_ww_tag_wh_float
    type: float
    restore_value: no
  - id: waermemertrag_electr_ww_tag_wh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_electr_ww_tag_kwh
    type: float
    restore_value: no
  - id: waermemertrag_electr_ww_tag_kwh_flag
    type: bool    
    restore_value: no

  - id: waermemertrag_heiz_tag_wh_float
    type: float
    restore_value: no
  - id: waermemertrag_heiz_tag_wh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_heiz_tag_kwh
    type: float
    restore_value: no
  - id: waermemertrag_heiz_tag_kwh_flag
    type: bool
    restore_value: no 

  - id: waermemertrag_electr_heiz_tag_wh_float
    type: float
    restore_value: no
  - id: waermemertrag_electr_heiz_tag_wh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_electr_heiz_tag_kwh
    type: float
    restore_value: no
  - id: waermemertrag_electr_heiz_tag_kwh_flag
    type: bool
    restore_value: no 

  - id: waermemertrag_ww_total_kWh_float
    type: float
    restore_value: no
  - id: waermemertrag_ww_total_kWh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_ww_total_mWh
    type: float
    restore_value: no
  - id: waermemertrag_ww_total_mWh_flag
    type: bool
    restore_value: no

  - id: waermemertrag_heiz_total_kWh_float
    type: float
    restore_value: no
  - id: waermemertrag_heiz_total_kWh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_heiz_total_mWh
    type: float
    restore_value: no
  - id: waermemertrag_heiz_total_mWh_flag
    type: bool
    restore_value: no

  - id: waermemertrag_electr_heiz_total_kWh_float
    type: float
    restore_value: no
  - id: waermemertrag_electr_heiz_total_kWh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_electr_heiz_total_mWh
    type: float
    restore_value: no
  - id: waermemertrag_electr_heiz_total_mWh_flag
    type: bool
    restore_value: no

  - id: waermemertrag_electr_ww_total_kWh_float
    type: float
    restore_value: no
  - id: waermemertrag_electr_ww_total_kWh_flag
    type: bool
    restore_value: no
  - id: waermemertrag_electr_ww_total_mWh
    type: float
    restore_value: no
  - id: waermemertrag_electr_ww_total_mWh_flag
    type: bool
    restore_value: no




#Abfrage des Sensorstatus durch Ausführen des Lambda-Befehls. send_state wird auf das request-Paket gesetzt. Anschließend wird Update_sensor aktiviert, der den Befehl via CAN absetzt und wieder deaktiviert
#Anturin tilan kyseleminen suorittamalla Lambda-komento. send_state on asetettu pyyntöpakettiin. Sitten Update_sensor aktivoituu, joka lähettää komennon CAN:n kautta ja deaktivoi sen uudelleen
sensor:
  - platform: template
    name: "Außentemperatur"
    #name: "Ulkolämpötila"
    id: temperature_outside
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x00;id(send_state)[4]=0x0c;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 10min


  - platform: template
    name: "Quellentemperatur"
    #name: "Lähteen lämpötila"
    id: temperature_source
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x01;id(send_state)[4]=0xd4;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 10min
    


  - platform: template
    name: "Warmwassertemperatur"
    #name: "Lämpimän veden lämpötila"
    id: temperature_water
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0x0e;id(send_state)[3]=0x01;id(send_state)[4]=0x00;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 10min

#In Planung
#  - platform: template
#    name: "WW_Programmstart"
#    id: ww_start
#    icon: "mdi:timer-play"
#    state_class: "measurement"
#    accuracy_decimals: 0

#In Planung
#  - platform: template
#    name: "WW_Programmende"
#    id: ww_ende
#    icon: "mdi:timer-stop"
#    state_class: "measurement"
#    accuracy_decimals: 0




#Berechnung COP erfolgt über Sensoren für Stromverbrauch und Wärmeproduktion - kein aktiver Update-Befehl
##COP:n laskenta tapahtuu sähkönkulutuksen ja lämmöntuotannon antureiden kautta - ei aktiivista päivityskomentoa
  - platform: template
    name: "Verdichterstarts"
    #name: "Kompressori käynnistyy"
    id: VD_starts
    unit_of_measurement: "a.u."
    icon: "mdi:chart-bell-curve-cumulative"
    device_class: "power_factor"
    state_class: "measurement"
    lambda: |-
      
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x07;id(send_state)[4]=0x1c;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
    
    
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x07;id(send_state)[4]=0x1d;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);

      if (id(VD_starts_t>0) and id(VD_starts_h>0)){
        float VD_starts_float = id(VD_starts_h)+id(VD_starts_t);
        return VD_starts_float;
      }
      else {return {};}
    update_interval: 5h
    accuracy_decimals: 0





  - platform: template
    name: "COP-Wert Heizung"
    #name: "COP-arvo lämmitys"
    id: cop_heater
    unit_of_measurement: "a.u."
    icon: "mdi:chart-bell-curve-cumulative"
    device_class: "power_factor"
    state_class: "measurement"
    accuracy_decimals: 2
    lambda: |-
      id(total_electric_energy_heating).update();
      id(total_heating_energy).update();
      id(total_electric_heating_energy).update();
      float heat_cop_float = (id(waermemertrag_heiz_total_mWh)+id(waermemertrag_electr_heiz_total_mWh))/id(el_aufnahmeleistung_heiz_total_mWh);
      return heat_cop_float;
    force_update: true


  - platform: template
    name: "COP-Wert Warmwasser"
    #name: "COP-arvo lämmin vesi"
    id: cop_water
    unit_of_measurement: "a.u."
    icon: "mdi:chart-bell-curve-cumulative"
    device_class: "power_factor"
    state_class: "measurement"
    accuracy_decimals: 2
    lambda: |-
      id(total_heating_energy_water).update();
      id(total_electric_energy_water).update();
      id(total_heating_energy_water).update();
      float ww_cop_float = (id(waermemertrag_ww_total_mWh)+id(waermemertrag_electr_ww_total_mWh))/id(el_aufnahmeleistung_ww_total_mWh);
      return ww_cop_float;
    force_update: true
    
  - platform: template
    name: "COP-Wert Gesamt"
    #name: "COP-arvo yhteensä"
    id: cop_total
    unit_of_measurement: "a.u."
    icon: "mdi:chart-bell-curve-cumulative"
    device_class: "power_factor"
    state_class: "measurement"
    accuracy_decimals: 2
    lambda: |-
      id(cop_water).update();
      id(cop_heater).update();
      float total_cop_float = ((id(waermemertrag_heiz_total_mWh)+id(waermemertrag_electr_heiz_total_mWh))+(id(waermemertrag_ww_total_mWh)+id(waermemertrag_electr_ww_total_mWh)))/(id(el_aufnahmeleistung_heiz_total_mWh)+id(el_aufnahmeleistung_ww_total_mWh));
      return total_cop_float;
    force_update: true
    update_interval: 6h




  - platform: template
    name: "Rücklauftemperatur Heizung"
    #name: "Lämmityksen paluulämpötila"
    id: temperature_return
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-left"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x00;id(send_state)[4]=0x16;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 5min



  - platform: template
    name: "T Heizkreis IST"
    #name: "T lämmityspiiri TODELLINEN"
    id: t_heizkreis_ist
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-right"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x02;id(send_state)[4]=0xca;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 5min


    
  - platform: template
    name: "T Heizkreis Soll"
    #name: "T lämmityspiiri TAVOITE"
    id: t_heizkreis_soll
    unit_of_measurement: "°C"
    icon: "mdi:waves-arrow-left"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x01;id(send_state)[4]=0xd7;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 15min


  - platform: template
    name: "Speicher Soll Temperatur"
    #name: "T varaajan TAVOITE"
    id: t_ww_soll
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-water"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0x03;id(send_state)[3]=0x00;id(send_state)[4]=0x00;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 15min






  - platform: template
    name: "Speicher IST Temperatur"
    #name: "T varaaja TODELLINEN"
    id: t_ww_ist
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1




  - platform: template
    name: "Eco Speicher Soll Temperatur"
    #name: "T Eco varaajan TAVOITE"
    id: ww_temp_eco_log
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-low"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x0a;id(send_state)[4]=0x06;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 10min




  - platform: template
    name: "Komfort Speicher Soll Temperatur"
    #name: "T Mukavuus varaaja TAVOITE"
    id: ww_temp_komfort_log
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-high"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0x13;id(send_state)[3]=0x00;id(send_state)[4]=0x00;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 10min




  - platform: template
    name: "Volumenstrom"
    #name: "Virtausnopeus"
    id: volumenstrom_log
    unit_of_measurement: "l/min"
    icon: "mdi:waves-arrow-right"
    state_class: "measurement"
    accuracy_decimals: 2
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x06;id(send_state)[4]=0x73;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 1min



  - platform: template
    name: "Heizungsdruck"
    #name: "Lämmityspaine"
    id: heizungsdruck_log
    unit_of_measurement: "bar"
    icon: "mdi:gauge"
    device_class: "pressure"
    state_class: "measurement"
    accuracy_decimals: 2
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x06;id(send_state)[4]=0x74;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      return {};
    update_interval: 7min



  - platform: template
    name: "Puffertemperatur"
    #name: "Puskurivaraajan lämpötila"
    id: puffertemperatur_log
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-high"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1


#Automatische Updates durch FEK
  - platform: template
    name: "Luftfeuchtigkeit Wohnraum"
    #name: "Asunnon kosteus"
    id: humidity_inside
    unit_of_measurement: "%rH"
    icon: "mdi:water-percent"
    device_class: "humidity"
    state_class: "measurement"
    accuracy_decimals: 1


  - platform: template
    name: "Temperatur Wohnraum"
    #name: "Asunnon lämpötila"
    id: temperature_inside
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    state_class: "measurement"
    accuracy_decimals: 1
    



  - platform: template
    name: "Stromverbrauch Warmwasser heute"
    #name: "Sähkönkulutus lämminvesi tänään"
    id: daily_electric_energy_water
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "measurement"
    accuracy_decimals: 3
    icon: "mdi:transmission-tower"
    lambda: |-
      //el. Leistungsaufnahme WW Tag Wh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x1a;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //el. Leistungsaufnahme WW Tag kWh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x1b;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      if (id(el_aufnahmeleistung_ww_tag_kwh_flag) and id(el_aufnahmeleistung_ww_tag_wh_flag)){
        id(el_aufnahmeleistung_ww_tag_kwh) += id(el_aufnahmeleistung_ww_tag_wh_float);
        float daily_electric_energy_water=id(el_aufnahmeleistung_ww_tag_kwh);
        id(el_aufnahmeleistung_ww_tag_kwh_flag)=false;
        id(el_aufnahmeleistung_ww_tag_wh_flag)=false;
        return daily_electric_energy_water;
        }
      else{return {};}
    update_interval: 15min

  - platform: template
    name: "WM Heizung heute"
    #name: "Lämmityksen WM?? tänään"
    id: daily_heating_energy
    unit_of_measurement: "kWh"
    device_class: "energy"
    icon: "mdi:water-boiler"
    state_class: "measurement"
    accuracy_decimals: 3
    lambda: |-
      //WM Heizen Tag wh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x2e;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //WM Heizen Tag kwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x2f;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      if (id(waermemertrag_heiz_tag_kwh_flag) and id(waermemertrag_heiz_tag_wh_flag)){
        id(waermemertrag_heiz_tag_kwh) += id(waermemertrag_heiz_tag_wh_float);
        float daily_heating_energy=id(waermemertrag_heiz_tag_kwh);
        id(waermemertrag_heiz_tag_kwh_flag)=false;
        id(waermemertrag_heiz_tag_wh_flag)=false;
        return daily_heating_energy;
        }
        else {
          return {};
        }
    update_interval: 15min


  - platform: template
    name: "Stromverbrauch Heizung heute"
    #name: "Sähkönkulutus lämmitys tänään"
    id: daily_electric_energy_heating
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "measurement"
    icon: "mdi:transmission-tower"
    accuracy_decimals: 3   
    lambda: |-
      //el. Leistungsaufnahme Heizen Tag Wh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x1e;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //el. Leistungsaufnahme Heizen Tag kWh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x1f;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      if (id(el_aufnahmeleistung_heiz_tag_kwh_flag) and id(el_aufnahmeleistung_heiz_tag_wh_flag)){
        id(el_aufnahmeleistung_heiz_tag_kwh) += id(el_aufnahmeleistung_heiz_tag_wh_float);
        float daily_electric_energy_heating=id(el_aufnahmeleistung_heiz_tag_kwh);
        id(el_aufnahmeleistung_heiz_tag_kwh_flag)=false;
        id(el_aufnahmeleistung_heiz_tag_wh_flag)=false;
        return daily_electric_energy_heating;
      }
      else{return {};}
    update_interval: 6h


  - platform: template
    name: "WM Warmwasser heute"
    #name: "Lämpimän veden WM?? tänään"
    id: daily_heating_energy_water
    unit_of_measurement: "kWh"
    device_class: "energy"
    icon: "mdi:water-boiler"
    state_class: "measurement"
    accuracy_decimals: 3
    lambda: |-
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x2a;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x2b;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      if (id(waermemertrag_ww_tag_kwh_flag) and id(waermemertrag_ww_tag_wh_flag)){
      id(waermemertrag_ww_tag_kwh) += id(waermemertrag_ww_tag_wh_float);
      float daily_heating_energy_water=id(waermemertrag_ww_tag_kwh);
      id(waermemertrag_ww_tag_kwh_flag)=false;
      id(waermemertrag_ww_tag_wh_flag)=false;
      return daily_heating_energy_water;
      }
      else{ return {};
      }
    update_interval: 15min

  - platform: template
    name: "Stromverbrauch Warmwasser total"
    #name: "Lämpimän veden kokonaiskulutus"
    id: total_electric_energy_water
    unit_of_measurement: "MWh"
    device_class: "energy"
    state_class: "total_increasing"
    icon: "mdi:transmission-tower"
    accuracy_decimals: 3
    lambda: |-
      //el. Leistungsaufnahme WW Summe kwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x1c;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //el. Leistungsaufnahme WW Summe Mwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x1d;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      if (id(el_aufnahmeleistung_ww_total_mWh_flag) and id(el_aufnahmeleistung_ww_total_kWh_flag)){
        id(el_aufnahmeleistung_ww_total_mWh) += id(el_aufnahmeleistung_ww_total_kWh_float);
        float total_electric_energy_water=id(el_aufnahmeleistung_ww_total_mWh);
        id(el_aufnahmeleistung_ww_total_mWh_flag)=false;
        id(el_aufnahmeleistung_ww_total_kWh_flag)=false;
        return total_electric_energy_water;
        }
      else {  return {};}



  - platform: template
    name: "Stromverbrauch Heizung total"
    #name: "Lämmityksen kokonaiskulutus"
    id: total_electric_energy_heating
    unit_of_measurement: "MWh"
    device_class: "energy"
    icon: "mdi:transmission-tower"
    state_class: "total_increasing"
    accuracy_decimals: 3
    lambda: |-
      //el. Leistungsaufnahme Heizen Summe kwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x20;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //el. Leistungsaufnahme Heizen Summe Mwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x21;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      if (id(el_aufnahmeleistung_heiz_total_mWh_flag) and id(el_aufnahmeleistung_heiz_total_kWh_flag)){
        id(el_aufnahmeleistung_heiz_total_mWh) += id(el_aufnahmeleistung_heiz_total_kWh_float);
        float total_electric_energy_heating=id(el_aufnahmeleistung_heiz_total_mWh);
        id(el_aufnahmeleistung_heiz_total_mWh_flag)=false;
        id(el_aufnahmeleistung_heiz_total_mWh_flag)=false;
        return total_electric_energy_heating;
        }
      else {return {};
        
      }



  - platform: template
    name: "WM Heizen total"
    #name: "Lämmityksen kokonais WM??"
    id: total_heating_energy
    unit_of_measurement: "MWh"
    device_class: "energy"
    icon: "mdi:water-boiler"
    state_class: "total_increasing"
    accuracy_decimals: 3
    lambda: |-
      //WM Heizen Summe kwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x30;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //WM Heizen Summe Mwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x31;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);

      //Überprüfung ob beide Leistungswerte empfangen wurden
      if (id(waermemertrag_heiz_total_kWh_flag) and id(waermemertrag_heiz_total_mWh_flag)){
        id(waermemertrag_heiz_total_mWh) += id(waermemertrag_heiz_total_kWh_float);
        float total_heating_energy=id(waermemertrag_heiz_total_mWh);
        id(waermemertrag_heiz_total_kWh_flag)=false;
        id(waermemertrag_heiz_total_mWh_flag)=false;
        return total_heating_energy;
        }
      else {
        return {};
      }
      
      
  - platform: template
    name: "WM Warmwasser total"
    #name: "Lämpimän veden kokonais WM??"
    id: total_heating_energy_water
    unit_of_measurement: "MWh"
    device_class: "energy"
    icon: "mdi:water-boiler"
    state_class: "total_increasing"
    accuracy_decimals: 3
    lambda: |-
      //WM WW Summe kwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x2c;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //WM WW Summe Mwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x2d;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      //Überprüfung ob beide Leistungswerte empfangen wurden
      if (id(waermemertrag_ww_total_mWh_flag) and id(waermemertrag_ww_total_kWh_flag)){
        id(waermemertrag_ww_total_mWh) += id(waermemertrag_ww_total_kWh_float);
        float total_heating_energy_water=id(waermemertrag_ww_total_mWh);
        id(waermemertrag_ww_total_mWh_flag)=false;
        id(waermemertrag_ww_total_kWh_flag)=false;
        return total_heating_energy_water;
        }
      else {
        return {};
        
      }


  - platform: template
    name: "WM elektr. Warmwasser total"
    #name: "Lämpimän veden kokonais WM elektr. ??"
    id: total_electric_heating_energy_water
    unit_of_measurement: "kWh"
    device_class: "energy"
    icon: "mdi:water-boiler"
    state_class: "total_increasing"
    accuracy_decimals: 3
    lambda: |-
      //WM NE WW Summe kwh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x24;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //WM NE WW Summe MWh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x25;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //Überprüfung ob beide Leistungswerte empfangen wurden
      if (id(waermemertrag_electr_ww_total_mWh_flag) and id(waermemertrag_electr_ww_total_kWh_flag)){
        id(waermemertrag_electr_ww_total_mWh) += id(waermemertrag_electr_ww_total_kWh_float);
        float total_electric_heating_energy_water=id(waermemertrag_electr_ww_total_mWh);
        id(waermemertrag_electr_ww_total_mWh_flag)=false;
        id(waermemertrag_electr_ww_total_kWh_flag)=false;
        return total_electric_heating_energy_water;
      }
      else {
        return {};
        
      }



  - platform: template
    name: "WM elektr. heizen total"
    #name: "Lämmityksen kokonais WM elektr. ??"
    id: total_electric_heating_energy
    unit_of_measurement: "kWh"
    device_class: "energy"
    icon: "mdi:water-boiler"
    state_class: "total_increasing"
    accuracy_decimals: 3
    lambda: |-
      //WM NE Heizen Summe kWh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x28;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //WM NE Heizen Summe MWh
      id(send_state)[0]=0x31;id(send_state)[1]=0x00;id(send_state)[2]=0xfa;id(send_state)[3]=0x09;id(send_state)[4]=0x29;id(send_state)[5]=0x00;id(send_state)[6]=0x00;
      id(update_sensor).publish_state(true);
      id(update_sensor).publish_state(false);
      
      //Überprüfung ob beide Leistungswerte empfangen wurden
      if (id(waermemertrag_electr_heiz_total_kWh_flag) and id(waermemertrag_electr_heiz_total_mWh_flag)){
        id(waermemertrag_electr_heiz_total_mWh) += id(waermemertrag_electr_heiz_total_kWh_float);
        float total_electric_heating_energy=id(waermemertrag_electr_heiz_total_mWh);
        id(waermemertrag_electr_heiz_total_kWh_flag)=false;
        id(waermemertrag_electr_heiz_total_mWh_flag)=false;
        return total_electric_heating_energy;
      }

      else {
        return {};
        
      }


text_sensor:
#Sensor zum verändern der Warmwasser-Komfort-Temperatur für Automatisierung mit PV-Anlage
  - platform: homeassistant
    name: "ww_komfort_temp"
    entity_id: input_text.ww_komfort_temp
    id: HASSeingabe_wwkomforttemp
    filters:
     - lambda: |-
          int eingabe=atoi(x.c_str());
          if (eingabe < 250 or eingabe > 600) {
            //Einfache Abfrage der Temperatur durchführen, falls keine gültige Eingabe erfolgt ist   
            id(send_state)[0]=0x31;
            id(send_state)[1]=0x00;
            id(send_state)[2]=0x13;
            id(send_state)[3]=0x00;
            id(send_state)[4]=0x00;
            id(send_state)[5]=0x00;
            id(send_state)[6]=0x00;
            return x;


          } else {
            //Wenn User-Eingabe gültig war, Daten für Übertragung an Heizung bereit machen
            id(send_state)[0]=0x30;
            id(send_state)[1]=0x00;
            id(send_state)[2]=0x13;
            id(send_state)[3]=eingabe>>8;
            id(send_state)[4]=eingabe-((eingabe>>8)<<8);
            id(send_state)[5]=0x00;
            id(send_state)[6]=0x00;
            return x;
            
          }
    on_value:
          then:
            - lambda: |-
                //Daten senden
                id(update_sensor).publish_state(true);
                id(update_sensor).publish_state(false);


#Sensor zum verändern der Warmwasser-Eco-Temperatur für Automatisierung mit PV-Anlage
#Anturi kuuman veden ekolämpötilan muuttamiseen PV-järjestelmän automatisoimiseksi
  - platform: homeassistant
    name: "ww_eco_temp"
    entity_id: input_text.ww_eco_temp
    id: HASSeingabe_wwecotemp
    filters:
     - lambda: |-
          int eingabe=atoi(x.c_str());
          if (eingabe < 250 or eingabe > 600) {

            id(send_state)[0]=0x31;
            id(send_state)[1]=0x00;
            id(send_state)[2]=0xfa;
            id(send_state)[3]=0x0a;
            id(send_state)[4]=0x06;
            id(send_state)[5]=0x00;
            id(send_state)[6]=0x00;
            return x;


          } else {

            id(send_state)[0]=0x30;
            id(send_state)[1]=0x00;
            id(send_state)[2]=0xfa;
            id(send_state)[3]=0x0a;
            id(send_state)[4]=0x06;
            id(send_state)[5]=eingabe>>8;
            id(send_state)[6]=eingabe-((eingabe>>8)<<8);
            return x;
            
          }
    on_value:
          then:
            - lambda: |-
                id(update_sensor).publish_state(true);
                id(update_sensor).publish_state(false);



binary_sensor:
# Heizraum Lichtschalter
  # - platform: gpio
    # pin:
      # number: GPIO16
      # mode: INPUT_PULLUP
    # id: licht_heizraum_bn
    # on_press:
      # then:
        # - homeassistant.service:
            # service: light.turn_on
            # data:
              # entity_id: light.eg_heizraum_waschraum


#Sensor zum Senden von CAN-Befehlen aus Lambda-Routinen
#Anturi CAN-komentojen lähettämiseen Lambda-rutiineista
  - platform: template
    id: update_sensor
    on_press:
      then:
        - canbus.send: 
            data: !lambda
              return {(uint8_t) id(send_state)[0],(uint8_t) id(send_state)[1],(uint8_t) id(send_state)[2],(uint8_t) id(send_state)[3], (uint8_t) id(send_state)[4],(uint8_t) id(send_state)[5],(uint8_t) id(send_state)[6]};
            can_id: 0x680


button:

#Button für CAN-Befehl im Log anzeigen - CAN-Befehl aus Home-Assistant-Dienst - es wird dabei kein Signal an den CAN-Bus gesendet; Führt auch erstmaliges refresh einzelner Sensoren aus
#Näytä lokissa CAN-komennon painike - CAN-komento Home Assistant -palvelusta - signaalia ei lähetetä CAN-väylään; Suorittaa myös yksittäisten antureiden alkupäivityksen
  - platform: template
    name: "Befehl anzeigen / Sensorupdate"
    #name: "Näytä komento / anturin päivitys"
    id: can_befehl_anzeigen
    on_press:
      then:      
        lambda: |-
         id(VD_starts).update();
         id(cop_total).update();
         ESP_LOGI("main", "Value of my hex_sensor: %x, %x, %x, %x, %x, %x, %x", id(sh_state)[0],id(sh_state)[1],id(sh_state)[2],id(sh_state)[3],id(sh_state)[4],id(sh_state)[5],id(sh_state)[6]);

#Button für CAN-Befehl absetzen - CAN-Befehl aus Home-Assistant-Dienst wird an CAN-Bus übermittelt
#CAN-komennon lähetyspainike - Home Assistant -palvelun CAN-komento välitetään CAN-väylään
  - platform: template
    name: CAN-Befehl absetzen
    #name: "Lähetä CAN-komento"
    id: can_send
    # Optional variables:
    icon: "mdi:emoticon-outline"
    on_press:
      then:
        - canbus.send: 
            data: !lambda
              return {(uint8_t) id(sh_state)[0],(uint8_t) id(sh_state)[1],(uint8_t) id(sh_state)[2],(uint8_t) id(sh_state)[3], (uint8_t) id(sh_state)[4],(uint8_t) id(sh_state)[5],(uint8_t) id(sh_state)[6]};
            can_id: 0x680


#Button zum automatisierten reset des ESP-Device
#Painike ESP-laitteen automaattiseen nollaukseen
  - platform: restart
    name: "Heizraum ESP restart"
    #name: "Lämpöpumpun ESP uudelleenkäynnistys"
    id: esp_heizraum_restart_bt
    on_press:
      - logger.log: "Button pressed"



#WW_Programm

#          - canbus.send:
#              data: [ 0x31, 0x00, 0xfa,0x17,0xa0,0x00,0x00 ]
#              can_id: 0x680
#          - delay: 500ms

#  { "HEISSGAS_TEMP"                                    , 0x0265, et_dec_val}, ok
#          - canbus.send:
#              data: [ 0x31, 0x00, 0xfa,0x02,0x65,0x00,0x00 ]
#              can_id: 0x680
#          - delay: 500ms

#Warmwasser Betriebsmodus Abfrage: - ok 1/10
#          - canbus.send:
#              data: [ 0x31, 0x00, 0xfa,0x01,0x12,0x00,0x00 ]
#              can_id: 0x680
#          - delay: 500ms


spi:
  id: McpSpi
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO19
canbus:
  - platform: mcp2515
    id: my_mcp2515
    spi_id: McpSpi
    cs_pin: GPIO15
    can_id: 680
    use_extended_id: false
    bit_rate: 50kbps
    on_frame:


#Verdichter Starts 1 000er
#Kompressori käynnistyy 1000s
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x07 and x[4]==0x1c) {
                float VD_x =float((int16_t((x[6])+( (x[5])<<8))))*1000;
                id(VD_starts_t)=VD_x;
                ESP_LOGD("main", "Verdichter Starts 1000 empfangen over can is %f", VD_x);
              }

#Verdichter Starts 100er         
#Kompressori käynnistyy 100s     
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x07 and x[4]==0x1d) {
                int VD_x =((int16_t((x[6])+( (x[5])<<8))));
                id(VD_starts_h)=VD_x;
                ESP_LOGD("main", "Verdichter Starts 100 empfangen over can is %i", VD_x);
              }

#T Heizkreis WW Komfort Soll Wert
#T lämmityspiirin WW mukavuustavoite
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0x13) {
              float temperature =(float((int16_t((x[4])+( (x[3])<<8))))/10);
              id(ww_temp_komfort_log).publish_state(temperature);
              ESP_LOGD("main", "T Komfort Soll empfangen over can is %f", temperature);
            }
#Volumenstrom (l/min)
#Tilavuusvirtaus (l/min)
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x06 and x[4]==0x73) {
              float current =(float((int16_t((x[6])+( (x[5])<<8))))/100);
              id(volumenstrom_log).publish_state(current);
              id(volumenstrom_float)=current;
              ESP_LOGD("main", "l/min Volumenstrom empfangen over can is %f", current);
            }

#Heizungsdruck (bar)
#Lämmityspaine (bar)
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x06 and x[4]==0x74) {
              float pressure =(float((int16_t((x[6])+( (x[5])<<8))))/100);
              id(heizungsdruck_log).publish_state(pressure);
              ESP_LOGD("main", "bar Heizungsdruck empfangen over can is %f", pressure);
            }
#T Puffertemperatur
#T puskurin lämpötila
        - lambda: |-
            if(x[0]==0x22 and x[1]==0x00 and x[2]==0x0e) {
              float temperature =(float((int16_t((x[4])+( (x[3])<<8))))/10);
              id(puffertemperatur_log).publish_state(temperature);
              ESP_LOGD("main", "T Puffertemperatur empfangen over can is %f", temperature);
            }


#T Heizkreis WW Eco Soll Abfrage
#T Lämmityspiiri WW Eco tavoitekysely
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[3]==0x0a and x[4]==0x06) {
              float temperature =(float((int16_t((x[6])+( (x[5])<<8))))/10);
              id(ww_temp_eco_log).publish_state(temperature);
              ESP_LOGD("main", "T Eco Soll empfangen over can is %f", temperature);
            }


#T Heizkreis IST Abfrage
#T Lämmityspiiri TODELLINEN kysely
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[3]==0x02 and x[4] == 0xca) {
              float temperature =(float((int16_t((x[6])+( (x[5])<<8))))/10);
              id(t_heizkreis_ist).publish_state(temperature);
              ESP_LOGD("main", "T Heizkreis IST empfangen over can is %f", temperature);
            }
#T Heizkreis Soll Abfrage
#T Lämmityspiirien tavoitekysely
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[3]==0x01 and x[4] == 0xd7) {
              float temperature =(float((int16_t((x[6])+( (x[5])<<8))))/10);
              id(t_heizkreis_soll).publish_state(temperature);
              ESP_LOGD("main", "T Heizkreis Soll empfangen over can is %f", temperature);
            }
#T WW Soll Abfrage
#T WW tavoitekysely
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0x03) {
              float temperature =(float((int16_t((x[4])+( (x[3])<<8))))/10);
              id(t_ww_soll).publish_state(temperature);
              ESP_LOGD("main", "T Warmwasser Soll empfangen over can is %f", temperature);
            }


#Warmwasser-Temperaturabfrage + Gerätespezifischer Offset 3.9 °C
#Lämpimän veden lämpötilakysely + laitekohtainen offset 3,9 °C
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[3]==0x00 and x[4] == 0x0e) {
              float temperature =(float((int16_t((x[6])+( (x[5])<<8))))/10)+3.9;
              id(temperature_water).publish_state(temperature);
              ESP_LOGD("main", "Warmwasser-Temperature empfangen over can is %f", temperature);
            }
            
#Quellen-Temperatur
#Lähdelämpötila
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[3]==0x01 and x[4] == 0xd4) {
              float temperature =float((int16_t((x[6])+( (x[5])<<8))))/10;
              id(temperature_source).publish_state(temperature);
              ESP_LOGD("main", "Quellen-Temperature received over can is %f", temperature);
            }

#Speicher IST-temperatur
#Muisti TODELLINEN lämpötila
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0x0e) {
              float temperature =float((int16_t((x[4])+( (x[3])<<8))))/10;
              id(t_ww_ist).publish_state(temperature);
              ESP_LOGD("main", "Speicher-Temperature received over can is %f", temperature);
            }

#Rücklauftemperatur
#Paluulämpötila
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[3]==0x00 and x[4] == 0x16) {
              float temperature =float((int16_t((x[6])+( (x[5])<<8))))/10;
              id(temperature_return).publish_state(temperature);
              ESP_LOGD("main", "Rücklauf-Temperature received over can is %f", temperature);
            }


#Außentemperatur
#float temperature =float(float((int((x[6])+( (x[5])<<8))))/10);
#Ulkolämpötila
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[3]==0x00 and x[4] == 0x0c) {
              float temperature =float((int16_t((x[6])+( (x[5])<<8))))/10;
              id(temperature_outside).publish_state(temperature);
              ESP_LOGD("main", "Aussen-Temperature received over can is %f", temperature);
            }





#Luftfeuchtigkeit FEK mitlesen
#Lue kosteus FEK?? (erillinen huoneanturi jota ei ole?)
    - can_id: 0x301
      then:
        - lambda: |-
            if(x[0]==0xc0 and x[1]==0x01 and x[2]==0x75) {
              float humidity =float(float((int16_t((x[4])+( (x[3])<<8))))/10);
              id(humidity_inside).publish_state(humidity);
              ESP_LOGD("main", "Humidity received over can is %f", humidity);
            }
#Raumtemperatur FEK mitlesen
#Lue huonelämpötila FEK?? (erillinen huoneanturi jota ei ole?)
    - can_id: 0x301
      then:
        - lambda: |-
            if(x[0]==0xc0 and x[1]==0x01 and x[2]==0x11) {
              float temperature =float((int16_t((x[4])+( (x[3])<<8))))/10;
              id(temperature_inside).publish_state(temperature);
              ESP_LOGD("main", "Raum-Temperature received over can is %f", temperature);
            }



#Elektrische Leistungsaufnahme Wh /kWh
#Sähkönkulutus Wh/kWh
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x09) {
              if (x[4]==0x1a){
                id(el_aufnahmeleistung_ww_tag_wh_float) = (float((int((x[6])+( (x[5])<<8))))/1000);
                id(el_aufnahmeleistung_ww_tag_wh_flag)=true;
                ESP_LOGD("main", "el_aufnahmeleistung_ww_tag_kwh received over can is %f", id(el_aufnahmeleistung_ww_tag_wh_float));}
              else if (x[4]==0x1e){
                id(el_aufnahmeleistung_heiz_tag_wh_float) = (float((int((x[6])+( (x[5])<<8))))/1000);
                id(el_aufnahmeleistung_heiz_tag_wh_flag) = true;
                ESP_LOGD("main", "el_aufnahmeleistung_heiz_tag_wh received over can is %f", id(el_aufnahmeleistung_heiz_tag_wh_float));}
              else if (x[4]==0x1c){
                id(el_aufnahmeleistung_ww_total_kWh_float) = (float((int((x[6])+( (x[5])<<8))))/1000);
                id(el_aufnahmeleistung_ww_total_kWh_flag)=true;
                ESP_LOGD("main", "el_aufnahmeleistung_ww_total_kWh received over can is %f", id(el_aufnahmeleistung_ww_total_kWh_float));}
              else if (x[4]==0x20){
                id(el_aufnahmeleistung_heiz_total_kWh_float) = (float((int((x[6])+( (x[5])<<8))))/1000);
                id(el_aufnahmeleistung_heiz_total_kWh_flag) = true;
                ESP_LOGD("main", "el_aufnahmeleistung_heiz_total_kWh received over can is %f", id(el_aufnahmeleistung_heiz_total_kWh_float));}
              }

#Elektrische Leistungsaufnahme kWh / MWH
#Sähkönkulutus kWh / MWH
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x09) {
              if(x[4]==0x1b){
              id(el_aufnahmeleistung_ww_tag_kwh) =float(int((x[6])+( (x[5])<<8)));
              id(el_aufnahmeleistung_ww_tag_kwh_flag)=true;
              ESP_LOGD("main", "el_aufnahmeleistung_ww_tag_kwh received over can is %f", id(el_aufnahmeleistung_ww_tag_kwh));}
              else if(x[4]==0x1f){
                id(el_aufnahmeleistung_heiz_tag_kwh) =float(int((x[6])+( (x[5])<<8)));
                id(el_aufnahmeleistung_heiz_tag_kwh_flag)=true;
                ESP_LOGD("main", "el_aufnahmeleistung_heiz_tag_kwh received over can is %f", id(el_aufnahmeleistung_heiz_tag_kwh));}
              else if(x[4]==0x1d){
              id(el_aufnahmeleistung_ww_total_mWh) =float(int((x[6])+( (x[5])<<8)));
              id(el_aufnahmeleistung_ww_total_mWh_flag)=true;
              ESP_LOGD("main", "el_aufnahmeleistung_ww_total_mWh received over can is %f", id(el_aufnahmeleistung_ww_total_mWh));}
              else if(x[4]==0x21){
                id(el_aufnahmeleistung_heiz_total_mWh) =float(int((x[6])+( (x[5])<<8)));
                id(el_aufnahmeleistung_heiz_total_mWh_flag)=true;
                ESP_LOGD("main", "el_aufnahmeleistung_heiz_total_mWh received over can is %f", id(el_aufnahmeleistung_heiz_total_mWh));}
            }


#Wärmeertrag WW/Heizung MWh / kWH
#Lämmöntuotto WW/lämmitys MWh/kWh
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x09) {
              if(x[4]==0x25){
                id(waermemertrag_electr_ww_total_mWh) =float(int((x[6])+( (x[5])<<8)));
                id(waermemertrag_electr_ww_total_mWh_flag)=true;
                ESP_LOGD("main", "waermemertrag_electr_ww_tag_kwh received over can is %f", id(waermemertrag_electr_ww_total_mWh));}
              else if(x[4]==0x29){
                id(waermemertrag_electr_heiz_total_mWh) =float(int((x[6])+( (x[5])<<8)));
                id(waermemertrag_electr_heiz_total_mWh_flag)=true;
                ESP_LOGD("main", "waermemertrag_electr_heiz_tag_kwh received over can is %f", id(waermemertrag_electr_heiz_total_mWh));}
              else if(x[4]==0x2b){
              id(waermemertrag_ww_tag_kwh) =float(int((x[6])+( (x[5])<<8)));
              id(waermemertrag_ww_tag_kwh_flag)=true;
              ESP_LOGD("main", "waermemertrag_ww_tag_kwh received over can is %f", id(waermemertrag_ww_tag_kwh));}
              else if(x[4]==0x2d){
              id(waermemertrag_ww_total_mWh) =float(int((x[6])+( (x[5])<<8)));
              id(waermemertrag_ww_total_mWh_flag)=true;
              ESP_LOGD("main", "waermemertrag_ww_total_mWh received over can is %f", id(waermemertrag_ww_total_mWh));}
              else if(x[4]==0x2f){
                id(waermemertrag_heiz_tag_kwh) =float(int((x[6])+( (x[5])<<8)));
                id(waermemertrag_heiz_tag_kwh_flag)=true;
                ESP_LOGD("main", "waermemertrag_heiz_tag_kwh received over can is %f", id(waermemertrag_heiz_tag_kwh));}
              else if(x[4]==0x31){
                id(waermemertrag_heiz_total_mWh) =float(int((x[6])+( (x[5])<<8)));
                id(waermemertrag_heiz_total_mWh_flag)=true;
                ESP_LOGD("main", "waermemertrag_heiz_total_kWh_float received over can is %f", id(waermemertrag_heiz_total_mWh));}
            }


#Wärmeertrag WW/Heizung Wh / kWH
#Lämmöntuotto WW/lämmitys Wh/kWh
    - can_id: 0x180
      then:
        - lambda: |-
            if(x[0]==0xd2 and x[1]==0x00 and x[2]==0xfa and x[3]==0x09) {
              if(x[4]==0x24){
                id(waermemertrag_electr_ww_total_kWh_float) =float(int((x[6])+( (x[5])<<8)))/1000;
                id(waermemertrag_electr_ww_total_kWh_flag)=true;
                ESP_LOGD("main", "waermemertrag_electr_ww_tag_wh_float received over can is %f", id(waermemertrag_electr_ww_total_kWh_float));}
              else if(x[4]==0x28){
                id(waermemertrag_electr_heiz_total_kWh_float) =float(int((x[6])+( (x[5])<<8)))/1000;
                id(waermemertrag_electr_heiz_total_kWh_flag)=true;
                ESP_LOGD("main", "waermemertrag_electr_heiz_tag_wh_float received over can is %f", id(waermemertrag_electr_heiz_total_kWh_float));}
              else if(x[4]==0x2a){
              id(waermemertrag_ww_tag_wh_float) =float(int((x[6])+( (x[5])<<8)))/1000;
              id(waermemertrag_ww_tag_wh_flag)=true;
              ESP_LOGD("main", "waermemertrag_ww_tag_wh_float received over can is %f", id(waermemertrag_ww_tag_wh_float));}
              else if(x[4]==0x2c){
              id(waermemertrag_ww_total_kWh_float) =float(int((x[6])+( (x[5])<<8)))/1000;
              id(waermemertrag_ww_total_kWh_flag)=true;
              ESP_LOGD("main", "waermemertrag_ww_total_kWh_float received over can is %f", id(waermemertrag_ww_total_kWh_float));}
              else if(x[4]==0x2e){
                id(waermemertrag_heiz_tag_wh_float) =float(int((x[6])+( (x[5])<<8)))/1000;
                id(waermemertrag_heiz_tag_wh_flag)=true;
                ESP_LOGD("main", "waermemertrag_heiz_tag_wh_float received over can is %f", id(waermemertrag_heiz_tag_wh_float));}
              else if(x[4]==0x30){
                id(waermemertrag_heiz_total_kWh_float) =float(int((x[6])+( (x[5])<<8)))/1000;
                id(waermemertrag_heiz_total_kWh_flag)=true;
                ESP_LOGD("main", "waermemertrag_heiz_total_kWh_float received over can is %f", id(waermemertrag_heiz_total_kWh_float));}
            }



    - can_id: 0x180
      then:
        - lambda: |-
              int wert0 = int(x[0]);
              int wert1 =int(x[1]);
              int wert2 =int(x[2]);
              int wert3 =int(x[3]);
              int wert4 =int(x[4]);
              int wert5 =int(x[5]);
              int wert6 =int(x[6]);
              float wert7 = float(int((x[6])+( (x[5])<<8)));
              float wert8 = float(int((x[4])+( (x[3])<<8)));
              ESP_LOGI("main", "Antwort von 180 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
              ESP_LOGI("main", "Antwort von 180 Float: %f", wert7);
              ESP_LOGI("main", "Antwort von 180 Dez.: %i %i", wert5, wert6);
              ESP_LOGI("main", "Antwort klein von 180 Float: %f", wert8);
              ESP_LOGI("main", "Antwort klein von 180 Dez.: %i %i", wert3, wert4);
              
    - can_id: 0x700
      then:
        - lambda: |-
              int wert0 = int(x[0]);
              int wert1 =int(x[1]);
              int wert2 =int(x[2]);
              int wert3 =int(x[3]);
              int wert4 =int(x[4]);
              int wert5 =int(x[5]);
              int wert6 =int(x[6]);
              float wert7 = float(int((x[6])+( (x[5])<<8)));
              float wert8 = float(int((x[4])+( (x[3])<<8)));
              ESP_LOGI("main", "Antwort von 700 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
              ESP_LOGI("main", "Antwort von 700 Float: %f", wert7);
              ESP_LOGI("main", "Antwort von 700 Dez.: %i %i", wert5, wert6);
              ESP_LOGI("main", "Antwort klein von 700 Float: %f", wert8);
              ESP_LOGI("main", "Antwort klein von 700 Dez.: %i %i", wert3, wert4);

    - can_id: 0x480
      then:
        - lambda: |-
              int wert0 = int(x[0]);
              int wert1 =int(x[1]);
              int wert2 =int(x[2]);
              int wert3 =int(x[3]);
              int wert4 =int(x[4]);
              int wert5 =int(x[5]);
              int wert6 =int(x[6]);
              float wert7 = float(int((x[6])+( (x[5])<<8)));
              float wert8 = float(int((x[4])+( (x[3])<<8)));
              ESP_LOGI("main", "Antwort von 480 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
              ESP_LOGI("main", "Antwort von 480 Float: %f", wert7);
              ESP_LOGI("main", "Antwort von 480 Dez.: %i %i", wert5, wert6);
              ESP_LOGI("main", "Antwort klein von 480 Float: %f", wert8);
              ESP_LOGI("main", "Antwort klein von 480 Dez.: %i %i", wert3, wert4);

    - can_id: 0x100
      then:
        - lambda: |-
              int wert0 = int(x[0]);
              int wert1 =int(x[1]);
              int wert2 =int(x[2]);
              int wert3 =int(x[3]);
              int wert4 =int(x[4]);
              int wert5 =int(x[5]);
              int wert6 =int(x[6]);
              float wert7 = float(int((x[6])+( (x[5])<<8)));
              float wert8 = float(int((x[4])+( (x[3])<<8)));
              ESP_LOGI("main", "Antwort von 100 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
              ESP_LOGI("main", "Antwort von 100 Float: %f", wert7);
              ESP_LOGI("main", "Antwort von 100 Dez.: %i %i", wert5, wert6);
              ESP_LOGI("main", "Antwort klein von 100 Float: %f", wert8);
              ESP_LOGI("main", "Antwort klein von 100 Dez.: %i %i", wert3, wert4);

    - can_id: 0x301
      then:
        - lambda: |-
              int wert0 = int(x[0]);
              int wert1 =int(x[1]);
              int wert2 =int(x[2]);
              int wert3 =int(x[3]);
              int wert4 =int(x[4]);
              int wert5 =int(x[5]);
              int wert6 =int(x[6]);
              float wert7 = float(int((x[6])+( (x[5])<<8)));
              float wert8 = float(int((x[4])+( (x[3])<<8)));
              ESP_LOGI("main", "Antwort von 301 Hex: %x %x %x %x %x %x %x", wert0, wert1, wert2, wert3, wert4, wert5, wert6);
              ESP_LOGI("main", "Antwort von 301 Float: %f", wert7);
              ESP_LOGI("main", "Antwort von 301 Dez.: %i %i", wert5, wert6);
              ESP_LOGI("main", "Antwort klein von 301 Float: %f", wert8);
              ESP_LOGI("main", "Antwort klein von 301 Dez.: %i %i", wert3, wert4);